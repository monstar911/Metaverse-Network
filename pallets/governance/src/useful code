// See `note_imminent_preimage`

    #[pallet::storage]
	pub type Preimages<T: Config> = StorageMap<
		_,
		Identity, T::Hash,
		PreimageStatus<T::AccountId, BalanceOf<T>, T::BlockNumber>,
	>;

	fn note_imminent_preimage_inner(who: T::AccountId, encoded_proposal: Vec<u8>) -> DispatchResult {
		let proposal_hash = T::Hashing::hash(&encoded_proposal[..]);
		Self::check_pre_image_is_missing(proposal_hash)?;
		let status = Preimages::<T>::get(&proposal_hash).ok_or(Error::<T>::NotImminent)?;
		let expiry = status.to_missing_expiry().ok_or(Error::<T>::DuplicatePreimage)?;

		let now = <frame_system::Pallet<T>>::block_number();
		let free = <BalanceOf<T>>::zero();
		let a = PreimageStatus::Available {
			data: encoded_proposal,
			provider: who.clone(),
			deposit: Zero::zero(),
			since: now,
			expiry: Some(expiry),
		};
		<Preimages<T>>::insert(proposal_hash, a);

		Self::deposit_event(Event::<T>::PreimageNoted(proposal_hash, who, free));

		Ok(())
	}

    // See `note_preimage`
	fn note_preimage_inner(who: T::AccountId, encoded_proposal: Vec<u8>) -> DispatchResult {
		let proposal_hash = T::Hashing::hash(&encoded_proposal[..]);
		ensure!(!<Preimages<T>>::contains_key(&proposal_hash), Error::<T>::DuplicatePreimage);

		let deposit = <BalanceOf<T>>::from(encoded_proposal.len() as u32)
			.saturating_mul(T::PreimageByteDeposit::get());
		T::Currency::reserve(&who, deposit)?;

		let now = <frame_system::Pallet<T>>::block_number();
		let a = PreimageStatus::Available {
			data: encoded_proposal,
			provider: who.clone(),
			deposit,
			since: now,
			expiry: None,
		};
		<Preimages<T>>::insert(proposal_hash, a);

		Self::deposit_event(Event::<T>::PreimageNoted(proposal_hash, who, deposit));

		Ok(())
	}

    fn do_enact_proposal(proposal_hash: T::Hash, index: ReferendumIndex) -> DispatchResult {
		let preimage = <Preimages<T>>::take(&proposal_hash);
		if let Some(PreimageStatus::Available { data, provider, deposit, .. }) = preimage {
			if let Ok(proposal) = T::Proposal::decode(&mut &data[..]) {
				let err_amount = T::Currency::unreserve(&provider, deposit);
				debug_assert!(err_amount.is_zero());
				Self::deposit_event(Event::<T>::PreimageUsed(proposal_hash, provider, deposit));

				let res = proposal.dispatch(frame_system::RawOrigin::Root.into())
					.map(|_| ()).map_err(|e| e.error);
				Self::deposit_event(Event::<T>::Executed(index, res));

				Ok(())
			} else {
				T::Slash::on_unbalanced(T::Currency::slash_reserved(&provider, deposit).0);
				Self::deposit_event(Event::<T>::PreimageInvalid(proposal_hash, index));
				Err(Error::<T>::PreimageInvalid.into())
			}
		} else {
			Self::deposit_event(Event::<T>::PreimageMissing(proposal_hash, index));
			Err(Error::<T>::PreimageMissing.into())
		}
	}